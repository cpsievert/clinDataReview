---
title: "Data visualization of the `medicalMonitoring` package"
author: "Laure Cougnaud"
date: "`r format(Sys.Date(), '%B %d, %Y')`"
params:
  createPatientProfiles: false
output: 
  rmarkdown::html_document:
    toc: true
    toc_float: true
    toc_depth: 5
    number_sections: true
vignette: >
  %\VignetteIndexEntry{Data visualization of the medicalMonitoring package}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r options, echo = FALSE, message = FALSE}

library(knitr)
library(plotly)
opts_chunk$set(
    echo = TRUE, 
    results = 'asis', 
    warning = FALSE, 
    error = FALSE, message = FALSE, cache = FALSE,
    fig.width = 8, fig.height = 7,
    fig.path = "./figures_vignette/",
    #out.width = '0.7\\textwidth', 
    fig.align = 'center')#, out.height = 0.5\\textwidth', fig.path = 'graphs/') 
options(width = 170)#, stringsAsFactors = FALSE
options(warn = 1)#instead of warn = 0 by default -> to have place where warnings occur in the call to Sweave function

heightLineIn  <- 0.2

```

```{r loadData}	

library(clinUtils)

data(dataADaMCDISCP01)
labelVars <- attr(dataADaMCDISCP01, "labelVars")

dataLB <- dataADaMCDISCP01$ADLBC
dataDM <- dataADaMCDISCP01$ADSL
dataAE <- dataADaMCDISCP01$ADAE

```

## Patient profiles

The interactive visualizations of the medical monitoring package include
functionalities to link a plot to patient-specific report, e.g. patient profiles
created with the `patientProfilesVis` package.

Such patient profiles can be created via a config file, with a dedicated
template report available in the `medicalMonitoring` package.

Plase, continue the documentation below to know how to set up a config file.

## Data visualization

### Visualization of individual profiles

Visualization of individual profiles is available via the function
`scatterplotMonitoring`.

Subject-specific report (e.g. patient profiles) can be linked to each profile
(`pathVar` parameter). If the user clicks on the 'P' key while hovering on the
plot, or click on the specific subject in the attached table, the specific
patient profile is opened in a new window in the browser.

#### Spaghetti plot of time profile

```{r timeProfiles}

labParam <- "ALT"
dataPlot <- subset(dataLB, PARAMCD == labParam)
dataPlot <- annotateData(dataPlot, annotations = list(data = dataDM))
visitLab <- with(dataPlot, tapply(ADY, VISIT, median))
names(visitLab) <- sub("-", "\n", names(visitLab))

# link to patient profiles
dataPlot$patientProfilePath <- paste0(
    "patientProfiles/subjectProfile-", 
    sub("/", "-", dataPlot$USUBJID), ".pdf"
)

scatterplotMonitoring(
    data = dataPlot, 
    xVar = "ADY",
    yVar = "LBSTRESN",
    aesPointVar = list(color = "ARM"),
    aesLineVar = list(group = "USUBJID", color = "ARM"),
    hoverVars = c("USUBJID", "VISIT", "ADY", "LBSTRESN", "ARM"),
    labelVars = labelVars,
    xPars = list(breaks = visitLab, labels = names(visitLab)),
    title = paste("Actual value of", 
        getLabelParamcd(
            paramcd = labParam, data = dataLB, paramcdVar = "PARAMCD", paramVar = "PARAM"
        )
    ),
    # include link to patient profiles:
    pathVar = "patientProfilePath",
    table = TRUE, id = paste("subjectProfile", labParam, sep = "-"),
    verbose = TRUE
)

```

#### Scatterplot

```{r scatterplot}

# format data long -> wide format (one column per lab param)
dataPlot <- subset(dataLB, PARAMCD %in% c("ALT", "ALB"))
dataPlot <- annotateData(dataPlot, annotations = list(data = dataDM))
library(reshape2)
dataPlotWide <- dcast(
    data = dataPlot,
    formula = USUBJID + VISIT + VISITNUM ~ PARAMCD, 
    value.var = "LBSTRESN",
    fun.aggregate = mean
)

# link to patient profiles
dataPlotWide$patientProfilePath <- paste0(
    "patientProfiles/subjectProfile-", 
    sub("/", "-", dataPlotWide$USUBJID), ".pdf"
)

# scatterplot per visit
scatterplotMonitoring(
    data = dataPlotWide, 
    xVar = "ALT", yVar = "ALB",
    xLab = getLabelParamcd(
        paramcd = "ALT", data = dataLB, paramcdVar = "PARAMCD", paramVar = "PARAM"
    ),
    yLab = getLabelParamcd(
        paramcd = "ALB", data = dataLB, paramcdVar = "PARAMCD", paramVar = "PARAM"
    ),
    aesPointVar = list(color = "USUBJID"),
    facetPars = list(facets = ~ VISIT),
    labelVars = labelVars,
    pathVar = "patientProfilePath",
    table = TRUE,
    verbose = TRUE
)

```

#### eDish plot

```{r eDishPlot}

dataLB <- annotateData(dataLB, annotations = list(data = dataDM))
dataALT <- subset(dataLB, PARAMCD == "ALT")
dataBILI <- subset(dataLB, PARAMCD == "BILI")
byVar <- c("USUBJID", "VISIT")
dataPlot <- merge(
    x = dataALT, y = dataBILI[, c(byVar, "LBSTRESN")], 
    by = c("USUBJID", "VISIT"), 
    suffixes = c(".ALT", ".BILI"),
    all = TRUE
)
labelVars[paste0("LBSTRESN.", c("ALT", "BILI"))] <-
    paste(
        "Actual value of", 
        getLabelParamcd(
            paramcd = c("ALT", "BILI"), data = dataLB, paramcdVar = "PARAMCD", paramVar = "PARAM"
        )
    )

# link to patient profiles
dataPlot$patientProfilePath <- paste0(
    "patientProfiles/subjectProfile-", 
    sub("/", "-", dataPlot$USUBJID), ".pdf"
)

# scatterplot per visit
scatterplotMonitoring(
    data = dataPlot, 
    xVar = "LBSTRESN.ALT", yVar = "LBSTRESN.BILI",
    xLab = getLabelParamcd(
        paramcd = "ALT", data = dataLB, paramcdVar = "PARAMCD", paramVar = "PARAM"
    ),
    yLab = getLabelParamcd(
        paramcd = "BILI", data = dataLB, paramcdVar = "PARAMCD", paramVar = "PARAM"
    ),
    aesPointVar = list(color = "VISIT", shape = "ARM"),
    xTrans = "log10", yTrans = "log10",
    hoverVars = c("USUBJID"),
    themePars = list(legend.position = "bottom"),
    labelVars = labelVars,
    table = TRUE, id = "eDish",
    pathVar = "patientProfilePath",
    verbose = TRUE
)

```

#### Visualization of time-intervals

Time-intervals are displayed with the `timeProfileIntervalPlot` function:

```{r timeProfileIntervalPlot}

# link to patient profiles
dataAE$patientProfilePath <- paste0(
    "patientProfiles/subjectProfile-", 
    sub("/", "-", dataAE$USUBJID), ".pdf"
)
timeProfileIntervalPlot(
    data = dataAE,
    paramVar = "USUBJID",
    # time-variables
    timeStartVar = "ASTDY",
    timeEndVar = "ASTDY",
    colorVar = "AESEV",
    hoverVars = c("USUBJID", "AEDECOD", "ASTDY", "AENDY", "AESEV"),
    labelVars = labelVars,
    table = TRUE, pathVar = "patientProfilePath",
    tableVars = c("USUBJID", "AEDECOD", "ASTDY", "AENDY", "AESEV"),
    verbose = TRUE
)

```

By default, empty intervals are represented if the start/end time variables are
missing. Missing start/end time can be imputed, or different symbols can be used
to represent such cases:

```{r timeProfileIntervalPlot-shapeVariables}

# create variable to indicate status of start/end date
dataAE$AESTFLG <- ifelse(is.na(dataAE$ASTDY), "Missing start", "Complete")
dataAE$AEENFLG <- ifelse(is.na(dataAE$AENDY), "Missing end", "Complete")
shapePalette <- c(
    `Missing start` = "triangle-left", 
    `Complete` = "square-open", 
    `Missing end` = "triangle-right"
)

# 'simple'-imputation:
# if start is missing, 'Missing' symbol displayed at end interval
dataAE$AESTDYIMP <- with(dataAE, ifelse(is.na(ASTDY), AENDY, ASTDY))
# if end is missing, 'Missing' symbol displayed at start interval
dataAE$AEENDYIMP <- with(dataAE, ifelse(is.na(AENDY), ASTDY, AENDY))

timeProfileIntervalPlot(
    data = dataAE,
    paramVar = "USUBJID", 
    # time-variables
    timeStartVar = "AESTDYIMP", timeStartLab = "Start day",
    timeEndVar = "AEENDYIMP", timeEndLab = "End day",
    # shape variables
    timeStartShapeVar = "AESTFLG",
    timeStartShapeLab = "Status of start date",
    timeEndShapeVar = "AEENFLG",
    timeEndShapeLab = "Status of end date",
    shapePalette = shapePalette,
    hoverVars = c("USUBJID", "AEDECOD", "AESEV", "ASTDY", "AESTFLG", "AENDY", "AEENFLG"),
    labelVars = labelVars,
    table = TRUE, 
    tableVars = c("USUBJID", "AEDECOD", "AESEV", "ASTDY", "AESTFLG", "AENDY", "AEENFLG"),
    pathVar = "patientProfilePath"
)

```

### Visualization of summary statistics

Summary statistics can also be visualized with the package, via different types
of visualizations: sunburst, treemap and barplot.

Subject-specific report (e.g. patient profiles) can be linked to each profile 
(`pathVar` parameter). If the user clicks on the 'P' key while hovering on the
plot, a zip file containing the reports for all corresponding patients is
downloaded. If the attached table is display, each row can be extended to
display the links of the respective patient profile reports.

These functions take as input a table of summary statistics, especially counts.
Such table can e.g. computed with the `inTextSummaryTable` R package (see
corresponding package vignette for more information).

In this example, counts of adverse events are extracted for each
`r labelVars["AESOC"]` and `r labelVars["AEDECOD"]`. Besides the counts of the
number of subjects, the paths to the patient profile report for each subgroup
are extracted and combined.

```{r createCountTableAE}

# sunburst takes as input table with counts
library(inTextSummaryTable)

# total counts: Safety Analysis Set (patients with start date for the first treatment)
dataTotal <- subset(dataDM, RFSTDTC != "")

## patient profiles report

# add path in data
dataAE$patientProfilePath <- paste0(
    "patientProfiles/subjectProfile-", 
    sub("/", "-", dataAE$USUBJID), ".pdf"
)

# add link in data (for attached table)
dataAE$patientProfileLink <- with(dataAE,
    paste0(
        '<a href="', patientProfilePath, 
        '" target="_blank">', USUBJID, '</a>'
    )
)

# combine all paths across patients
# the paths should be collapsed with: ', '
statsExtraPP <- list(
    statPatientProfilePath = function(data)	
      toString(sort(unique(data$patientProfilePath))),
    statPatientProfileLink = function(data)
      toString(sort(unique(data$patientProfileLink)))
)

# get default counts + stats with subjects profiles path
statsPP <- c(
    getStats(type = "count-default"),
    list(
        patientProfilePath = quote(statPatientProfilePath),
        patientProfileLink = quote(statPatientProfileLink)
    )
)

# compute adverse event table
tableAE <- getSummaryStatisticsTable(
    
    data = dataAE,
    rowVar = c("AESOC", "AEDECOD"),
    dataTotal = dataTotal,
    rowOrder = "total",
    labelVars = labelVars,
    
    # plotly treemap requires records (rows) for each group
    rowVarTotalInclude = "AEDECOD",
    
    ## DT-output specific:
    outputType = "data.frame-base",
    # statistics of interest
    # for DT output, include columns with patients
    stats = statsPP, 
    # add extra 'statistic': concatenate subject IDs
    statsExtra = statsExtraPP

)
pander(head(tableAE),
    caption = paste("Extract of the Adverse Event summary table",
        "used for the sunburst and barplot visualization"
    )
)

```

#### Sunburst

The `sunburstMonitoring` function visualizes the counts of hierarchical data in
nested circles.

The different groups are visualized from the biggest class (root node) in the
center of the visualization to the smallest sub-groups (leaves) on the outside
of the circles.

The size of the different segments is relative the respective counts.

```{r sunburst}

dataSunburst <- tableAE

dataSunburst$n <- as.numeric(dataSunburst$n)

sunburstMonitoring(
    data = dataSunburst,
    vars = c("AESOC", "AEDECOD"),
    valueVar = "n", valueLab = "Number of patients with adverse events",
    pathVar = "patientProfileLink",
    pathLab = clinUtils::getLabelVar(var = "USUBJID", labelVars = labelVars),
    table = TRUE,
    verbose = TRUE,
    labelVars = labelVars
)

```

#### Treemap

A treemap visualizes the counts of the hierarchical data in nested rectangles.
The area of each rectangle is proportional to the counts of the respective
group.

```{r treemap}

dataTreemap <- tableAE

dataTreemap$n <- as.numeric(dataTreemap$n)

treemapMonitoring(
    data = dataTreemap,
    vars = c("AESOC", "AEDECOD"),
    valueVar = "n", valueLab = "Number of patients with adverse events",
    pathVar = "patientProfileLink",
    pathLab = clinUtils::getLabelVar(var = "USUBJID", labelVars = labelVars),
    table = TRUE,
    verbose = TRUE,
    labelVars = labelVars
)

```

#### Barplot

A barplot visualizes the counts for one single variable in a specific order.

```{r barplot}

dataPlot <- subset(tableAE, AEDECOD != "Total")

dataPlot$n <- as.numeric(dataPlot$n)

# create plot
barplotMonitoring(
    data = dataPlot,
    xVar = "AESOC", colorVar = "AEDECOD",
    yVar = "n",
    yLab = "Number of patients with adverse events",
    labelVars = labelVars,
    pathVar = "patientProfileLink",
    pathLab = clinUtils::getLabelVar(var = "USUBJID", labelVars = labelVars),
    table = TRUE,
    verbose = TRUE,
    barmode = "stack"
)

```

### Multiple visualizations in a loop

To include multiple medical monitoring visualizations (with or without attached
table) in a loop (in the same _Rmarkdown_ chunk), the list of visualizations
should be passed to the `knitPrintListObjects` function of the `clinUtils`
package.

```{r lab-profile-loop, results = "asis"}

# consider only restricted set of lab parameters
dataPlot <- subset(dataLB, PARAMCD %in% c("SODIUM", "K"))

# link to patient profiles
dataPlot$patientProfilePath <- paste0(
    "patientProfiles/subjectProfile-", 
    sub("/", "-", dataPlot$USUBJID), ".pdf"
)

# 1) create plot+table for each laboratory parameter:
library(plyr) # for ddply
plotsLab <- dlply(dataPlot, "PARAMCD", function(dataLBParam){
      
      paramcd <- unique(dataLBParam$PARAMCD)
      
      scatterplotMonitoring(
          data = dataLBParam, 
          xVar = "ADY",
          yVar = "LBSTRESN",
          aesPointVar = list(color = "TRT01P"),
          aesLineVar = list(group = "USUBJID", color = "TRT01P"),
          labelVars = labelVars,
          title = paste("Actual value of", 
              getLabelParamcd(
                  paramcd = paramcd, data = dataLBParam, paramcdVar = "PARAMCD", paramVar = "PARAM"
              )
          ),
          # include link to patient profiles:
          pathVar = "patientProfilePath",
          table = TRUE, 
          # important: each plot should have an unique ID!
          # for unique relationship of interactivity between plot <-> table
          id = paste("labProfileLoop", paramcd, sep = "-"),
          verbose = TRUE
      )
      
    })

# include this output in the report:
listLabels <- getLabelParamcd(
    paramcd = names(plotsLab), data = dataLB, paramcdVar = "PARAMCD", paramVar = "PARAM"
)
clinUtils::knitPrintListObjects(
    xList = plotsLab, 
    titles = listLabels, titleLevel = 4
)

```

### Palettes

#### Set palette for the entire session

Palette for the colors and shapes associated with specific variables can be set
for all medical monitoring visualizations at once by setting the
`medicalMonitoring.colors` and `medicalMonitoring.shapes` options at the start
of the R session.

Please see the `clinUtils` package for the default colors and shapes.

```{r palettes-default-get}

# display default palettes
colorsDefault <- getOption("medicalMonitoring.colors")
colorsDefault
shapesDefault <- getOption("medicalMonitoring.shapes")
shapesDefault

```

```{r palettes-default-example}

timeProfileIntervalPlot(
    data = dataAE,
    paramVar = "USUBJID",
    # time-variables
    timeStartVar = "ASTDY",
    timeEndVar = "AENDY",
    colorVar = "AESEV",
    timeStartShapeVar = "AESTFLG",
    timeEndShapeVar = "AEENFLG",
    labelVars = labelVars
)

```

The palettes can be set for all visualizations, e.g. at the start of the R
session, with:

```{r palettes-customGeneral-set}

# change palettes for the entire R session
options(medicalMonitoring.colors = c("gold", "pink", "cyan"))
options(medicalMonitoring.shapes = clinShapes)

```

In case the palette contains less elements than available in the data, these are
replicated.

```{r palettes-customGeneral-example}

timeProfileIntervalPlot(
    data = dataAE,
    paramVar = "USUBJID",
    # time-variables
    timeStartVar = "ASTDY",
    timeEndVar = "AENDY",
    colorVar = "AESEV",
    timeStartShapeVar = "AESTFLG",
    timeEndShapeVar = "AEENFLG",
    labelVars = labelVars
)

```

Palettes are reset to the default patient profiles palettes at the start of a
new R session, or by setting:

```{r palettes-default-reset}

# change palettes for the entire R session
options(medicalMonitoring.colors = colorsDefault)
options(medicalMonitoring.shapes = shapesDefault)

```
