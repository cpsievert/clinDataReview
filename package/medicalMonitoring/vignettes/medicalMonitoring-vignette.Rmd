---
title: "Vignette of the `medicalMonitoring` package"
author: "Laure Cougnaud"
date: "`r format(Sys.Date(), '%B %d, %Y')`"
params:
  createPatientProfiles: false
output: medicalMonitoring::html_medicalMonitoring_report
vignette: >
  %\VignetteIndexEntry{Introduction to the medicalMonitoring package}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

# Introduction

```{r options, echo = FALSE, message = FALSE}
	
	library(knitr)
	library(plotly)
	opts_chunk$set(
		echo = TRUE, 
#		results = 'asis', 
		warning = FALSE, 
		error = FALSE, message = FALSE, cache = FALSE,
		fig.width = 8, fig.height = 7,
		fig.path = "./figures_vignette/",
		#out.width = '0.7\\textwidth', 
		fig.align = 'center')#, out.height = 0.5\\textwidth', fig.path = 'graphs/') 
	options(width = 170)#, stringsAsFactors = FALSE
	options(warn = 1)#instead of warn = 0 by default -> to have place where warnings occur in the call to Sweave function
	
	heightLineIn  <- 0.2
	
```

This package `medicalMonitoring` contains visualizations/reporting functionalities
for medical monitoring.

```{r loadPackages, message = FALSE}

	library(medicalMonitoring)
	library(pander)

```

## Report

The functionality to download the patient profiles require additional _Javascript_ functions/packages:

* custom _Javascript_ functions
* external _Javascript_ dependencies: _JSZip_, _JSZipUtils_, _FileSaver_

These dependencies are included in the `medicalMonitoring` package.

To create a report containing such visualization,
dedicated output formats should be specified in the YAML header of the document:

* for a [_Rmarkdown_](https://cran.r-project.org/package=rmarkdown) report: : `html_medicalMonitoring_report`
```
---
title: "Study name"
subtitle: "Analysis description"
output: html_medicalMonitoring_report
---
```

* for a [_bookdown_](https://cran.r-project.org/package=bookdown) report: `gitbook_medicalMonitoring_report`
```
---
title: "Study name"
subtitle: "Analysis description"
output: gitbook_medicalMonitoring_report
---
```


## Data format

The input dataset for the workflow should be a data.frame, 
usually loaded from a _SAS_ data file (`sas7bdat` format).
The label of the variables stored in the `SAS` datasets is also used
for title/captions. 

The function `loadDataADaMSDTM` can be used to load your custom `SAS` dataset(s) of
interest.
This function returns two objects:

* a list of `data.frame` containing the data for each _SAS_ dataset(s), stored
  in the `$data` slot
* a vector containing the labels for each column of the data (used e.g. for
  default titles of the figures), stored in the `$labelVars` slot

A few `sdtm` datasets from the _Pelican_ study are included in the
`glpgUtilityFct` package for the demonstration, via the dataset
`SDTMDataPelican` and corresponding variable labels `labelVarsSDTMPelican`.

```{r loadData}	
	
	library(glpgUtilityFct)
	
	data(SDTMDataPelican)
	data(labelVarsSDTMPelican)
	
	dataLB <- SDTMDataPelican$LB
	dataDM <- SDTMDataPelican$DM
	dataAE <- SDTMDataPelican$AE
	labelVars <- labelVarsSDTMPelican

```

# Data pre-processing

## Add data annotation

The `annotateData` enables to add metadata for a specific domain/dataset.

```{r annotateData, message = TRUE}
dataLB <- annotateData(dataLB, annotations = list(data = dataDM), verbose = TRUE)
pander(
	head(dataLB), 
	caption = paste("Laboratory parameters annotated with",
		"demographics information with the `annotatedData` function"
	)
)
```

## Transform data

The `transformData` enables to convert data to a different format.

For example, the laboratory data is converted from a long format, containing
one record per endpoint*visit*subject to a wide format containing
one record per visit*subject, the endpoints being included in different columns.

```{r transformData, message = TRUE}

	eDishData <- transformData(
		data = subset(dataLB, LBTESTCD %in% c("ALT", "BILI")),
		transformations = list(
			type = "pivot_wider",
			varsID = c("USUBJID", "VISIT"), 
			varsValue = c("LBSTRESN", "LBNRIND"),
			varPivot = "LBTESTCD"
		),
		verbose = TRUE,
		labelVars = labelVars
	)
	pander(head(eDishData))

```

# Visualizations

## Patient profiles

The interactive visualizations of the medical monitoring package include
functionalities to link a plot to specific patient profiles report.

A standard patient profiles report for _SDTM_ input format is created with the function:
`runPatientProfileTemplateReport`.

```{r createPatientProfilesReport, eval = params$createPatientProfiles, results = "hide"}

	library(patientProfilesVis)
	
	# export example data
	dataPath <- "data";dir.create(dataPath)
	library(haven)
	dataPathFiles <- sapply(names(SDTMDataPelican), function(dm){
		# issue for empty col
		idxCol <- !sapply(SDTMDataPelican[[dm]], function(x) all(x == ""))
		dataPathDM <- file.path(dataPath, paste0(dm, ".sas7bdat"))
		write_sas(
			data = SDTMDataPelican[[dm]][, idxCol], 
			path = dataPathDM
		)
		dataPathDM
	})
#	sapply(dataPathFiles, read_sas)

	# create patient profile report
	runPatientProfileTemplateReport(
		dataPath = dataPath, 
		outputFile = "patientProfiles/subjectProfile.pdf",
		study = "Pelican",
		batch = "20180606",
		author = "Laure Cougnaud",
		overwrite = TRUE
	)

```

## Data visualization

### Visualization of individual profiles

Visualization of individual profiles is available via the function
`scatterplotMonitoring`.

Subject-specific report (e.g. patient profiles) can be linked to each profile
(`pathVar` parameter).
If the user clicks on the 'P' key while hovering on the plot, or click
on the specific subject in the attached table, the specific
patient profile is opened in a new window in the browser.

#### Spaghetti plot of time profile

```{r timeProfiles}

labParam <- "ALT"
dataPlot <- subset(dataLB, LBTESTCD == labParam)
visitLab <- with(dataPlot, tapply(LBDY, VISIT, median))
names(visitLab) <- sub("-", "\n", names(visitLab))

# link to patient profiles
dataPlot$patientProfilePath <- paste0(
	"patientProfiles/subjectProfile-", 
	sub("/", "-", dataPlot$USUBJID), ".pdf"
)

scatterplotMonitoring(
	data = dataPlot, 
	xVar = "LBDY", yVar = "LBSTRESN",
	aesPointVar = list(color = "ACTARM"),
	aesLineVar = list(group = "USUBJID", color = "ACTARM"),
	hoverVars = c("USUBJID", "VISIT", "LBDY", "LBSTRESN", "COUNTRY", "ACTARM"),
	labelVars = labelVars,
	xPars = list(breaks = visitLab, labels = names(visitLab)),
#	themePars = list(legend.position = "none"),
	title = paste("Actual value of", 
		getLabelParamcd(paramcd = labParam, data = dataLB, paramcdVar = "LBTESTCD", paramVar = "LBTEST")
	),
	# include link to patient profiles:
	pathVar = "patientProfilePath",
	table = TRUE, id = paste("subjectProfile", labParam, sep = "-"),
	verbose = TRUE
)

```

#### Scatterplot

```{r scatterplot}

# format data long -> wide format (one column per lab param)
dataPlot <- subset(dataLB, LBTESTCD %in% c("ALT", "ALB"))
library(reshape2)
dataPlotWide <- dcast(
	data = dataPlot,
	formula = USUBJID + VISIT + VISITNUM ~ LBTESTCD, 
	value.var = "LBSTRESN",
	fun.aggregate = mean
)

# link to patient profiles
dataPlotWide$patientProfilePath <- paste0(
	"patientProfiles/subjectProfile-", 
	sub("/", "-", dataPlotWide$USUBJID), ".pdf"
)

# scatterplot per visit
scatterplotMonitoring(
	data = dataPlotWide, 
	xVar = "ALT", yVar = "ALB",
	xLab = getLabelParamcd(paramcd = "ALT", data = dataLB, paramcdVar = "LBTESTCD", paramVar = "LBTEST"),
	yLab = getLabelParamcd(paramcd = "ALB", data = dataLB, paramcdVar = "LBTESTCD", paramVar = "LBTEST"),
	aesPointVar = list(color = "USUBJID"),
#	themePars = list(legend.position = "none"),
	facetPars = list(facets = ~ VISIT),
	labelVars = labelVars,
	pathVar = "patientProfilePath",
	table = TRUE,
	verbose = TRUE
)


```

#### eDish plot

```{r eDishPlot}

	dataALT <- subset(dataLB, LBTESTCD == "ALT")
	dataBILI <- subset(dataLB, LBTESTCD == "BILI")
	byVar <- c("USUBJID", "VISIT")
	dataPlot <- merge(
		x = dataALT, y = dataBILI[, c(byVar, "LBSTRESN")], 
		by = c("USUBJID", "VISIT"), 
		suffixes = c(".ALT", ".BILI"),
		all = TRUE
	)
	labelVars[paste0("LBSTRESN.", c("ALT", "BILI"))] <-
		paste(
			"Actual value of", 
			getLabelParamcd(paramcd = c("ALT", "BILI"), data = dataLB, paramcdVar = "LBTESTCD", paramVar = "LBTEST")
		)
	
	# link to patient profiles
	dataPlot$patientProfilePath <- paste0(
		"patientProfiles/subjectProfile-", 
		sub("/", "-", dataPlot$USUBJID), ".pdf"
	)

	# scatterplot per visit
	scatterplotMonitoring(
		data = dataPlot, 
		xVar = "LBSTRESN.ALT", yVar = "LBSTRESN.BILI",
		xLab = getLabelParamcd(paramcd = "ALT", data = dataLB, paramcdVar = "LBTESTCD", paramVar = "LBTEST"),
		yLab = getLabelParamcd(paramcd = "BILI", data = dataLB, paramcdVar = "LBTESTCD", paramVar = "LBTEST"),
		aesPointVar = list(color = "VISIT", shape = "ACTARM"),
		xTrans = "log10", yTrans = "log10",
		hoverVars = c("USUBJID"),
		themePars = list(legend.position = "bottom"),
		labelVars = labelVars,
		table = TRUE, id = "eDish",
		pathVar = "patientProfilePath",
		verbose = TRUE
	)

```

#### Visualization of time-intervals

Time-intervals are displayed with the `timeProfileIntervalPlot` function:

```{r timeProfileIntervalPlot}

	# link to patient profiles
	dataAE$patientProfilePath <- paste0(
		"patientProfiles/subjectProfile-", 
		sub("/", "-", dataAE$USUBJID), ".pdf"
	)
	timeProfileIntervalPlot(
		data = dataAE,
		paramVar = "USUBJID",
		# time-variables
		timeStartVar = "AESTDY",
		timeEndVar = "AEENDY",
		colorVar = "AESEV",
		hoverVars = c("USUBJID", "AEDECOD", "AESTDY", "AEENDY", "AESEV"),
		labelVars = labelVars,
		table = TRUE, pathVar = "patientProfilePath",
		tableVars = c("USUBJID", "AEDECOD", "AESTDY", "AEENDY", "AESEV"),
		verbose = TRUE
	)

```

By default, empty intervals are represented if the start/end time variables are missing.
Missing start/end time can be imputed, or different symbols
can be used to represent such cases:

```{r timeProfileIntervalPlot-shapeVariables}
	
	# create variable to indicate status of start/end date
	dataAE$AESTFLG <- ifelse(is.na(dataAE$AESTDY), "Missing start", "Complete")
	dataAE$AEENFLG <- ifelse(is.na(dataAE$AEENDY), "Missing end", "Complete")
	shapePalette <- c(
		`Missing start` = "triangle-left", 
		`Complete` = "square-open", 
		`Missing end` = "triangle-right"
	)
	
	# 'simple'-imputation:
	# if start is missing, 'Missing' symbol displayed at end interval
	dataAE$AESTDYIMP <- with(dataAE, ifelse(is.na(AESTDY), AEENDY, AESTDY))
	# if end is missing, 'Missing' symbol displayed at start interval
	dataAE$AEENDYIMP <- with(dataAE, ifelse(is.na(AEENDY), AESTDY, AEENDY))

	timeProfileIntervalPlot(
		data = dataAE,
		paramVar = "USUBJID", 
		# time-variables
		timeStartVar = "AESTDYIMP", timeStartLab = "Start day",
		timeEndVar = "AEENDYIMP", timeEndLab = "End day",
		# shape variables
		timeStartShapeVar = "AESTFLG", timeStartShapeLab = "Status of start date",
		timeEndShapeVar = "AEENFLG", timeEndShapeLab = "Status of end date",
		shapePalette = shapePalette,
		hoverVars = c("USUBJID", "AEDECOD", "AESEV", "AESTDY", "AESTFLG", "AEENDY", "AEENFLG"),
		labelVars = labelVars,
		table = TRUE, 
		tableVars = c("USUBJID", "AEDECOD", "AESEV", "AESTDY", "AESTFLG", "AEENDY", "AEENFLG"),
		pathVar = "patientProfilePath"
	)

```

### Visualization of summary statistics

Summary statistics can also be visualized with the package, 
via different types of visualizations:
sunburst, treemap and barplot.

Subject-specific report (e.g. patient profiles) can be linked to each profile 
(`pathVar` parameter). If the user clicks on the 'P' key while hovering on the plot, 
a zip file containing the reports for all corresponding patients is downloaded.
If the attached table is display, each row can be extended to display the links 
of the respective patient profile reports.

These functions take as input a table of summary statistics, especially counts.
Such table can e.g. computed with the `inTextSummaryTable` R package (see
corresponding package vignette for more information).

In this example, counts of adverse events are extracted for each `r labelVars["AESOC"]`
and `r labelVars["AEDECOD"]`.
Besides the counts of the number of subjects, the paths to the patient profile report
for each subgroup are extracted and combined.

```{r createCountTableAE}

	# sunburst takes as input table with counts
	library(inTextSummaryTable)
	
	# total counts: Safety Analysis Set (patients with start date for the first treatment)
	dataTotal <- subset(dataDM, RFXSTDTC != "")
	
	## patient profiles report
	
	# add path in data
	dataAE$patientProfilePath <- paste0(
		"patientProfiles/subjectProfile-", 
		sub("/", "-", dataAE$USUBJID), ".pdf"
	)
	
	# add link in data (for attached table)
	dataAE$patientProfileLink <- with(dataAE,
		paste0(
			'<a href="', patientProfilePath, 
			'" target="_blank">', USUBJID, '</a>'
		)
	)
	
	# combine all paths across patients
	# the paths should be collapsed with: ', '
	statsExtraPP <- list(
		statPatientProfilePath = function(data)	
			toString(sort(unique(data$patientProfilePath))),
		statPatientProfileLink = function(data)
			toString(sort(unique(data$patientProfileLink)))
	)
	
	# get default counts + stats with subjects profiles path
	statsPP <- c(
		getStats(type = "count-default"),
		list(
			patientProfilePath = quote(statPatientProfilePath),
			patientProfileLink = quote(statPatientProfileLink)
		)
	)
	
	# compute adverse event table
	tableAE <- getSummaryStatisticsTable(
					
		data = dataAE,
		rowVar = c("AESOC", "AEDECOD"),
		dataTotal = dataTotal,
		rowOrder = "total",
		labelVars = labelVars,
		
		# plotly treemap requires records (rows) for each group
		rowVarTotalInclude = "AEDECOD",
		
		## DT-output specific:
		outputType = "data.frame",
		# statistics of interest
		# for DT output, include columns with patients
		stats = statsPP, 
		# add extra 'statistic': concatenate subject IDs
		statsExtra = statsExtraPP

	)
	pander(head(tableAE),
		caption = paste("Extract of the Adverse Event summary table",
			"used for the sunburst and barplot visualization"
		)
	)

```

#### Sunburst

The `sunburstMonitoring` function visualizes the counts 
of hierarchical data in nested circles.

The different groups are visualized from the biggest class (root node)
in the center of the visualization to the smallest sub-groups (leaves)
on the outside of the circles.

The size of the different segments is relative the respective counts.

```{r sunburst}

	dataSunburst <- tableAE
	
	dataSunburst$n <- as.numeric(dataSunburst$n)

	sunburstMonitoring(
		data = dataSunburst,
		vars = c("AESOC", "AEDECOD"),
		valueVar = "n", valueLab = "Number of patients with adverse events",
		pathVar = "patientProfileLink", pathLab = getLabelVar(var = "USUBJID", labelVars = labelVars),
		table = TRUE,
		verbose = TRUE,
		labelVars = labelVars
	)
	
```

#### Treemap

A treemap visualizes the counts of the hierarchical data in nested
rectangles.
The area of each rectangle is proportional to the counts
of the respective group.

```{r treemap}

	dataTreemap <- tableAE
	
	dataTreemap$n <- as.numeric(dataTreemap$n)
	
	treemapMonitoring(
		data = dataTreemap,
		vars = c("AESOC", "AEDECOD"),
		valueVar = "n", valueLab = "Number of patients with adverse events",
		pathVar = "patientProfileLink", pathLab = getLabelVar(var = "USUBJID", labelVars = labelVars),
		table = TRUE,
		verbose = TRUE,
		labelVars = labelVars
	)
	
```

#### Barplot

A barplot visualizes the counts for one single variable in a specific order.

```{r barplot}

	dataPlot <- subset(tableAE, AEDECOD != "Total")
	
	dataPlot$n <- as.numeric(dataPlot$n)
	
	# create plot
	barplotMonitoring(
		data = dataPlot,
		xVar = "AEDECOD", colorVar = "AESOC",
		yVar = "n", yLab = "Number of patients with adverse events",
		labelVars = labelVars,
		pathVar = "patientProfileLink", pathLab = getLabelVar(var = "USUBJID", labelVars = labelVars),
		table = TRUE,
		verbose = TRUE
	)
	
```

### Multiple visualizations in a loop

To include multiple medical monitoring visualizations (with or without attached table)
in a loop (a.k.a in the same _Rmarkdown_ chunk), the list of visualizations
should be passed to the `knitPrintListObjects` function of the `glpgUtilityFct`
package.

```{r lab-profile-loop, results = "asis"}

	# consider only restricted set of lab parameters
	dataPlot <- subset(dataLB, LBCAT == "SPECIAL CHEMISTRY")

	# link to patient profiles
	dataPlot$patientProfilePath <- paste0(
		"patientProfiles/subjectProfile-", 
		sub("/", "-", dataPlot$USUBJID), ".pdf"
	)
	
	# 1) create plot+table for each laboratory parameter:
	library(plyr) # for ddply
	plotsLab <- dlply(dataPlot, "LBTESTCD", function(dataLBParam){
				
		paramcd <- unique(dataLBParam$LBTESTCD)
			
		scatterplotMonitoring(
			data = dataLBParam, 
			xVar = "LBDY", yVar = "LBSTRESN",
			aesPointVar = list(color = "ACTARM"),
			aesLineVar = list(group = "USUBJID", color = "ACTARM"),
			labelVars = labelVars,
			title = paste("Actual value of", 
				getLabelParamcd(paramcd = paramcd, data = dataLBParam, paramcdVar = "LBTESTCD", paramVar = "LBTEST")
			),
			# include link to patient profiles:
			pathVar = "patientProfilePath",
			table = TRUE, 
			# important: each plot should have an unique ID!
			# for unique relationship of interactivity between plot <-> table
			id = paste("labProfileLoop", paramcd, sep = "-"),
			verbose = TRUE
		)
			
	})

	# include this output in the report:
	library(glpgUtilityFct)
	listLabels <- getLabelParamcd(paramcd = names(plotsLab), data = dataLB, paramcdVar = "LBTESTCD", paramVar = "LBTEST")
	knitPrintListObjects(
		xList = plotsLab, 
		generalLabel = "lab-profile-loop",
		titles = listLabels, titleLevel = 4
	)

```

# Render a medical monitoring report

## File structure

### Input

The input for the medical monitoring report consists of:

* A set of _Rmarkdown_ files in the current directory
    + _index.Rmd_ file, containing the front page of the document.  
This file should be formatted as a _Rmarkdown_ report with _YAML_ header,
with `output` set to: `medicalMonitoring::gitbook_medicalMonitoring_report`
    + multiple Rmd files, one for each chapter (or template for multiple chapters)
* a `config` directory containing:
    + a general configuration file: _config.yml_ with:
        + `pathDataFolder`: path to a directory containing input data in _sas7bdat_
        or _xpt_ format
        + `patientProfilesPath`(optional) : path to a directory containing the patient profiles
        + `study` (optional): study name
        + `version` (optional): data version, e.g. batch
    + a configuration file for each chapter, as: _config-[chapterName].yml_ containing:
        + `template`: filename of the _Rmd_ file to consider for this chapter
        + `reportTitle`: chapter title, used for section header
        + `fileName`: filename of the dataset of interest for this chapter, e.g.: 'adae.sas7bdat'
        + `level`: integer with section level, e.g. 2
        + (optional) template-specific parameters, accessed in the template
        via `params$`
        
#### Output

The medical monitoring report output consists of:

* a final output folder ('MOMP' by default) containing the:
    + final medical monitoring report, in a set of
multiple HTML files
    + required _Javascript_ libraries in the subfolder: _'libs'_
    + any extra directories created during report execution, by
    default: 'tables' and 'figures' (`extraDirs` parameter)
    + (optionally) directory with patient profiles
* a folder of intermediary results ('interim' by default)
    + _Markdown_ file for each report part (one per config file)
    + associated _rds_ file containing specification of the
    _Javascript_ libraries required for each report part (`knit_meta`)

## Production mode

The function **`render_medicalMonitoringReport` renders a medical monitoring report
for production**.

```{r render_medicalMonitoringReport, eval = FALSE}
medicalMonitoring::render_medicalMonitoringReport()
```

## Development mode

### Modular framework

#### (Re-)run part(s) of the report

In case the creation of the entire report is time-consuming, and
only part(s) of the report have been updated, it might be interesting to
only re-run some parts of the report. Config files associated to the
parts of the report that should be rerun can be specified via the
`configFiles` parameter.

```{r render_medicalMonitoringReport-configFiles, eval = FALSE}
medicalMonitoring::render_medicalMonitoringReport(configFiles = "config-AE_timeprofile.yml")
```

#### Create the final medical monitoring report from the Markdown reports

To convert all created _Markdown_ files to HTML, the dedicated function `convertMdToHtml`
can be used.

```{r convertMdToHtml, eval = FALSE}

	convertMdToHtml()

```

### Debug a sub-report

To debug a sub-report, it might be interesting to run
only one specific R report in the current R session, with
the parameters provided by the associated config file.
This can be achieved as followed:

```{r render_medicalMonitoringReport-devel, eval = FALSE}

# get parameters from the general 'config.yml' and the specified config file
params <- getParamsFromConfig(configFile = "config-AE_timeprofile.yml")

# run a current chapter (without medical monitoring Js libraries and GLPG style)
# Note that Js library to have the functionality to download patient profiles is not imported
rmarkdown::render(input = params$template)

# preview a specific chapter (with medical monitoring Js libraries and GLPG style)
bookdown::render_book(input = params$template, preview = TRUE)
# include the index file:
bookdown::render_book(input = c("index.Rmd", params$template), preview = TRUE)

```

# For package tester/developer

To run the different tests in the package (e.g. with `R CMD check`),
the [orca](https://github.com/plotly/orca) tool is required.
Please check the installation guidelines available at:
https://github.com/plotly/orca#installation

# Appendix

## Session information

```{r includeSessionInfo, echo = FALSE}

	library(pander)
	pander(sessionInfo())

```
